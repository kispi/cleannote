const fs = require('fs');
const path = require('path');

// Config
const USER_ID = 1; // Assuming user ID 1 exists
const BUILDING_COUNT = 20;
const START_YEAR = 2023;
const END_YEAR = 2026;
const OUTPUT_FILE = 'seed_data.sql';

// Buildings Data
const buildingNames = [
  '행복 빌라', '미소 아파트', '푸른 오피스텔', '드림 타워', '스타 건물',
  '해피 하우스', '그린 맨션', '스카이 뷰', '리버 사이드', '골든 팰리스',
  '센트럴 파크', '시티 뷰', '노블레스', '로얄 층', '선샤인 빌',
  '문라이트', '스타라이트', '갤럭시 타워', '우주 맨션', '지구 빌라'
];

const addresses = [
    '서울 강남구 역삼동', '서울 서초구 서초동', '서울 송파구 잠실동', '경기 성남시 분당구', '경기 수원시 팔달구'
];

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomItem(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function generateBuildings() {
  const sqls = [];
  sqls.push(`INSERT INTO buildings (user_id, name, address, price_per_clean, scheduled_days, created_at, updated_at) VALUES`);
  
  const values = [];
  for (let i = 1; i <= BUILDING_COUNT; i++) {
    const name = `${randomItem(buildingNames)} ${i}동`;
    const address = `${randomItem(addresses)} ${randomInt(1, 999)}번지`;
    const price = randomInt(3, 15) * 5000; // 15000 ~ 75000
    const days = [1, 3, 5].join(','); // Mon, Wed, Fri
    
    // index i will be the ID if auto-increment works sequentially on empty table, 
    // but here we just insert.
    values.push(`(${USER_ID}, '${name}', '${address}', ${price}, '${days}', NOW(), NOW())`);
  }
  
  sqls.push(values.join(',\n') + ';');
  return sqls.join('\n');
}

function generateLogs() {
  const sqls = [];
  // We assume building IDs 1 to BUILDING_COUNT exist after the first insert.
  // In a real scenario, we might need actual IDs, but for a seed script on clean DB or known state, 1-N is fine.
  // Or we can just assume they will be inserted and get IDs starting from... let's assume 1 for simplicity 
  // or user should adjust. 
  // Actually, better to use LAST_INSERT_ID() logic or variables but simple INSERT VALUES is requested.
  // I will just assume IDs 1~20.
  
  const BATCH_SIZE = 500;
  let currentValues = [];
  
  const startDate = new Date(`${START_YEAR}-01-01`);
  const endDate = new Date(`${END_YEAR}-12-31`);
  const today = new Date(); // To avoid future if desirable? User said "last few years". 2026 is current year.
  
  sqls.push(`-- Cleaning Logs (Assuming Building IDs 1~${BUILDING_COUNT} exist)`);
  
  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    if (d > today) break; // Don't generate future logs? Or maybe a few scheduled ones? User said "sales statistics", so past/completed logs.
    
    // For each day, random chance for each building to be cleaned
    for (let bId = 1; bId <= BUILDING_COUNT; bId++) {
        // 30% chance per day per building (approx 2 times a week)
        if (Math.random() < 0.3) {
            const cleanStart = new Date(d);
            cleanStart.setHours(randomInt(9, 17), randomInt(0, 5) * 10, 0); // 9:00 ~ 17:50
            
            const cleanEnd = new Date(cleanStart);
            cleanEnd.setMinutes(cleanEnd.getMinutes() + randomInt(30, 90));
            
            // Format MySQL Timestamp 'YYYY-MM-DD HH:mm:ss'
            const fmt = (date) => date.toISOString().slice(0, 19).replace('T', ' ');
            
            const earned = randomInt(3, 15) * 5000; // Just random price 
            
            const row = `(${bId}, '${fmt(cleanStart)}', '${fmt(cleanEnd)}', 'completed', ${earned}, NOW(), NOW())`;
            currentValues.push(row);
            
            if (currentValues.length >= BATCH_SIZE) {
                sqls.push(`INSERT INTO cleaning_logs (building_id, clean_start, clean_end, status, earned_amount, created_at, updated_at) VALUES`);
                sqls.push(currentValues.join(',\n') + ';');
                currentValues = [];
            }
        }
    }
  }
  
  if (currentValues.length > 0) {
    sqls.push(`INSERT INTO cleaning_logs (building_id, clean_start, clean_end, status, earned_amount, created_at, updated_at) VALUES`);
    sqls.push(currentValues.join(',\n') + ';');
  }
  
  return sqls.join('\n');
}

const sql = [
  '-- Mock Data Seed Script',
  '-- Generated by CleanNote Agent',
  '',
  '-- 1. Insert Buildings',
  generateBuildings(),
  '',
  '-- 2. Insert Cleaning Logs',
  generateLogs()
].join('\n\n');

fs.writeFileSync(OUTPUT_FILE, sql);
console.log(`Successfully generated ${OUTPUT_FILE}`);
